<!DOCTYPE html><html lang="en" class="h-full">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ultimate Solar System Explorer</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; font-family: 'Space Mono', monospace; }
    #info-panel { position: absolute; top: 10px; right: 10px; background: rgba(10, 20, 40, 0.9); padding: 1rem; border-radius: 1rem; color: white; max-width: 300px; }
    .panel-title { font-family: 'Orbitron', monospace; font-weight: bold; font-size: 1.2rem; margin-bottom: 0.5rem; }
  </style>
</head>
<body class="h-full bg-black">
  <div id="info-panel">
    <div class="panel-title" id="planet-name">Click a planet</div>
    <div id="planet-type"></div>
    <div id="planet-diameter"></div>
    <div id="planet-mass"></div>
    <div id="planet-gravity"></div>
    <div id="planet-orbit"></div>
  </div>
  <script>
// ================================
// Scene Setup
// ================================
const scene = new THREE.Scene();
scene.background = new THREE.Color('#000010');const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.set(0, 100, 300);

const renderer = new THREE.WebGLRenderer({antialias: true}); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.1; controls.minDistance = 50; controls.maxDistance = 1000;

// ================================ // Lights // ================================ const sunLight = new THREE.PointLight(0xffffff, 2, 0); sunLight.position.set(0,0,0); scene.add(sunLight);

const ambientLight = new THREE.AmbientLight(0x222222); scene.add(ambientLight);

// ================================ // Starfield // ================================ function createStars() { const starGeometry = new THREE.BufferGeometry(); const starCount = 2000; const positions = new Float32Array(starCount * 3);

for(let i=0; i<starCount*3; i++) { positions[i] = (Math.random() - 0.5) * 2000; }

starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); const starMaterial = new THREE.PointsMaterial({color: 0xffffff, size: 0.7}); const stars = new THREE.Points(starGeometry, starMaterial); scene.add(stars); } createStars();

// ================================ // Planet Textures // ================================ const textureLoader = new THREE.TextureLoader();

const planetData = [ { name: 'Sun', type: 'G-type Star', diameter: '1,392,700 km', mass: '1.99×10³⁰ kg', gravity: '274 m/s²', orbitRadius: 0, speed: 0, texture: 'https://i.imgur.com/9e4ON3R.jpg', size: 20 }, { name: 'Mercury', type: 'Terrestrial Planet', diameter: '4,879 km', mass: '3.30×10²³ kg', gravity: '3.7 m/s²', orbitRadius: 28, speed: 0.04, texture: 'https://i.imgur.com/R9AIl5U.jpg', size: 2 }, { name: 'Venus', type: 'Terrestrial Planet', diameter: '12,104 km', mass: '4.87×10²⁴ kg', gravity: '8.87 m/s²', orbitRadius: 40, speed: 0.015, texture: 'https://i.imgur.com/5H0Vt4y.jpg', size: 3.5 }, { name: 'Earth', type: 'Rocky Planet', diameter: '12,742 km', mass: '5.97×10²⁴ kg', gravity: '9.8 m/s²', orbitRadius: 60, speed: 0.01, texture: 'https://i.imgur.com/8iU0sxN.jpg', size: 4 }, { name: 'Mars', type: 'Red Planet', diameter: '6,779 km', mass: '6.42×10²³ kg', gravity: '3.71 m/s²', orbitRadius: 80, speed: 0.008, texture: 'https://i.imgur.com/9gkLhkb.jpg', size: 3 } ];

const planets = [];

planetData.forEach(data => { const geometry = new THREE.SphereGeometry(data.size, 32, 32); const material = new THREE.MeshStandardMaterial({map: textureLoader.load(data.texture)}); const planet = new THREE.Mesh(geometry, material); planet.userData = data; scene.add(planet); planets.push(planet); });

// ================================ // Orbits (visualization) // ================================ planetData.forEach(data => { if(data.orbitRadius > 0){ const orbit = new THREE.RingGeometry(data.orbitRadius - 0.05, data.orbitRadius + 0.05, 64); const orbitMat = new THREE.MeshBasicMaterial({color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.2}); const orbitMesh = new THREE.Mesh(orbit, orbitMat); orbitMesh.rotation.x = Math.PI/2; scene.add(orbitMesh); } });

// ================================ // Planet Selection Info // ================================ const info = { name: document.getElementById('planet-name'), type: document.getElementById('planet-type'), diameter: document.getElementById('planet-diameter'), mass: document.getElementById('planet-mass'), gravity: document.getElementById('planet-gravity'), orbit: document.getElementById('planet-orbit') };

const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();

window.addEventListener('click', (event)=>{ mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(planets); if(intersects.length > 0){ const data = intersects[0].object.userData; info.name.textContent = data.name; info.type.textContent = Type: ${data.type}; info.diameter.textContent = Diameter: ${data.diameter}; info.mass.textContent = Mass: ${data.mass}; info.gravity.textContent = Gravity: ${data.gravity}; info.orbit.textContent = data.orbitRadius > 0 ? Orbit Radius: ${data.orbitRadius} : ''; } });

// ================================ // Animation Loop // ================================ function animate(){ requestAnimationFrame(animate); controls.update();

const time = Date.now() * 0.001; planets.forEach(planet => { if(planet.userData.orbitRadius > 0){ planet.position.x = Math.cos(time * planet.userData.speed) * planet.userData.orbitRadius; planet.position.z = Math.sin(time * planet.userData.speed) * planet.userData.orbitRadius; } else { planet.position.set(0,0,0); // Sun at center } planet.rotation.y += 0.002; // Planet rotation });

renderer.render(scene, camera); } animate();

window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }); </script>

</body>
</html>